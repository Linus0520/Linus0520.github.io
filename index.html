<!DOCTYPE html>
<html lang="zh">
  <head>
    <!-- Meta ä¿¡æ¯ -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ•°å­¦ç»ƒä¹ ç¤ºä¾‹</title>
    <style>
      /* æ ·å¼éƒ¨åˆ† */
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        /* è°ƒæ•´å¸ƒå±€ï¼Œä½¿å†…å®¹å……æ»¡å±å¹• */
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        background-color: #f3f3f3;
      }
      .container {
        display: flex;
        flex-direction: row;
        width: 100%;
        max-width: 1366px;
        /* ä½¿å†…å®¹è‡ªé€‚åº”é«˜åº¦ */
        flex-grow: 1;
        background-color: #ffffff;
        margin: auto; /* å±…ä¸­æ˜¾ç¤º */
      }
      .questions-area {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 2px 2px;
        width: 68%; /* è°ƒæ•´å®½åº¦ï¼Œä½¿ç”»å¸ƒåŒºåŸŸæ›´é å³ */
        padding: 5px;
        background-color: #f9f9f9;
        overflow-y: auto;
      }
      .question {
        display: flex;
        align-items: center;
        padding: 0 2px;
        background-color: #ffffff;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s ease;
        height: 120px;
        position: relative;
        overflow: hidden;
      }
      .question.active,
      .question:hover {
        background-color: #e8f5e9;
      }
      .question .expression {
        display: flex;
        align-items: center;
        width: 100%;
        height: 100%;
      }
      .question .question-text {
        font-size: 3vw;
        font-weight: bold;
        color: #333;
        flex: 0 0 auto;
        min-width: 80px;
        margin-right: 5px;
        line-height: 1;
      }
      .question .answer-container {
        flex: 1;
        display: flex;
        align-items: center;
        height: 100%;
        overflow: hidden;
      }
      .question .answer-img {
        max-height: 100%;
        width: auto;
        height: auto;
        object-fit: contain;
      }
      .question .answer-text {
        font-size: 3vw;
        font-weight: bold;
        color: #333;
        text-align: center;
      }
      .canvas-area {
        display: flex;
        flex-direction: column;
        width: 32%; /* è°ƒæ•´å®½åº¦ */
        padding: 2px;
        background-color: #ffffff;
      }
      .page-navigation {
        display: flex;
        align-items: center;
        margin-left: auto; /* ä½¿å…¶é å³å¯¹é½ */
      }
      .page-navigation button {
        background-color: #add8e6; /* æ·¡è“è‰²èƒŒæ™¯ */
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 6px 12px; /* å¢å¤§æŒ‰é’®å°ºå¯¸ */
        cursor: pointer;
        margin: 0 5px;
        font-size: 16px; /* å¢å¤§å­—ä½“ */
      }
      /* æ˜¾ç¤ºè¢«é€‰ä¸­çš„é¢˜ç›® */
      .selected-question {
        font-size: 5vw; /* æ ¹æ®å±å¹•å®½åº¦è‡ªåŠ¨è°ƒæ•´ */
        font-weight: bold;
        color: #333;
        margin: 20% 0 10px 0; /* ä¸Šä¸‹é—´è·ï¼Œå¢å¤§ä¸é¡¶éƒ¨çš„è·ç¦» */
        text-align: center;
      }
      .tool-buttons {
        display: flex;
        justify-content: center;
        margin-bottom: 5px;
      }
      .tool-buttons button {
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        margin: 0 5px;
        cursor: pointer;
        font-size: 20px;
      }
      .tool-buttons button.selected {
        border: 2px solid #4caf50;
        background-color: #e8f5e9;
      }
      .canvas-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative; /* ä¸ºäº†å®šä½åˆ‡æ¢æŒ‰é’® */
        margin-top: auto; /* å°†ç”»å¸ƒæ¨åˆ°æœ€åº•éƒ¨ */
      }
      /* è¾“å…¥åŒºåŸŸï¼ŒåŒ…å«ç”»å¸ƒå’Œæ•°å­—è¾“å…¥ç»„ä»¶ */
      .input-area {
        position: relative;
        width: 95%;
        max-width: 400px;
        aspect-ratio: 1 / 1; /* ä½¿å…¶ä¿æŒæ­£æ–¹å½¢ */
        border: 2px solid #ccc;
        border-radius: 8px;
        margin-bottom: 10px;
        overflow: hidden;
      }
      .input-area canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      /* æ•°å­—æ˜¾ç¤ºåŒºåŸŸ */
      .numeric-display {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 30%; /* å æ®é¡¶éƒ¨30% */
        display: none; /* é»˜è®¤éšè— */
        font-size: 8vw; /* è°ƒæ•´æ•°å­—æ˜¾ç¤ºçš„å¤§å° */
        font-weight: bold;
        color: #333;
        background-color: #fff;
        align-items: center;
        justify-content: center;
        z-index: 2;
      }
      /* æ•°å­—é”®ç›˜åŒºåŸŸ */
      .numeric-keypad {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 70%; /* å æ®åº•éƒ¨70% */
        display: none; /* é»˜è®¤éšè— */
        background-color: rgba(255, 255, 255, 0.9);
        flex-wrap: wrap;
        align-items: center;
        justify-content: center;
        z-index: 1;
      }
      .numeric-keypad button {
        width: 25%;
        margin: 0.5%;
        font-size: 3vw; /* è°ƒæ•´å­—ä½“å¤§å°ï¼Œä½¿æŒ‰é’®æ›´å° */
        border: 1px solid #ccc;
        border-radius: 8px;
        cursor: pointer;
        padding: 3px 0; /* å‡å° padding */
        background-color: #fff;
      }
      /* åˆ‡æ¢è¾“å…¥æ¨¡å¼çš„æŒ‰é’®æ ·å¼ */
      .toggle-input-mode {
        position: absolute;
        top: 5px;
        left: 5px;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        cursor: pointer;
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 4; /* ç¡®ä¿æŒ‰é’®åœ¨æœ€ä¸Šå±‚ */
      }
      .confirm-button {
        background-color: #4caf50;
        color: #fff;
        border: none;
        border-radius: 8px;
        padding: 8px 40%;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s ease;
      }
      .confirm-button:hover {
        background-color: #45a049;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- é¢˜ç›®åŒºåŸŸ -->
      <div class="questions-area" id="questions">
        <!-- åŠ¨æ€ç”Ÿæˆé¢˜ç›® -->
      </div>

      <!-- ç”»å¸ƒåŒºåŸŸ -->
      <div class="canvas-area">
        <!-- ç¿»é¡µæŒ‰é’® -->
        <div class="page-navigation">
          <button id="prev-page">ä¸Šä¸€é¡µ</button>
          <span
            >ç¬¬ <span id="page-number">1</span>/<span id="total-pages">1</span>
            é¡µ</span
          >
          <button id="next-page">ä¸‹ä¸€é¡µ</button>
        </div>
        <!-- æ˜¾ç¤ºè¢«é€‰ä¸­çš„é¢˜ç›® -->
        <div class="selected-question"></div>
        <!-- ç”»å¸ƒå’Œç¡®è®¤æŒ‰é’®å®¹å™¨ -->
        <div class="canvas-container">
          <!-- åˆ‡æ¢è¾“å…¥æ¨¡å¼çš„æŒ‰é’® -->
          <button id="toggle-input-mode" class="toggle-input-mode">ğŸ”„</button>
          <!-- å·¥å…·æŒ‰é’® -->
          <div class="tool-buttons" id="tool-buttons">
            <button id="pen-button">âœ</button>
            <button id="eraser-button">âŒ«</button>
          </div>
          <!-- è¾“å…¥åŒºåŸŸ -->
          <div class="input-area">
            <!-- ç”»å¸ƒ -->
            <canvas id="canvas"></canvas>
            <!-- æ•°å­—è¾“å…¥æ˜¾ç¤ºæ¡† -->
            <div class="numeric-display" id="numeric-display"></div>
            <!-- æ•°å­—è¾“å…¥é”®ç›˜ -->
            <div class="numeric-keypad" id="numeric-keypad">
              <!-- åŠ¨æ€ç”Ÿæˆæ•°å­—æŒ‰é’® -->
            </div>
          </div>
          <button class="confirm-button" onclick="confirmAnswer()">
            âœ” ç¡®è®¤
          </button>
        </div>
      </div>
    </div>

    <script>
      const questionsContainer = document.getElementById("questions");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      let drawing = false;
      let activeQuestionIndex = null; // åˆå§‹ä¸é€‰ä¸­ä»»ä½•é¢˜ç›®
      let currentTool = "pen";
      let currentPage = 0;
      const totalQuestions = 50; // æ€»å…±50é“é¢˜
      const questionsPerPage = 10;
      const totalPages = Math.ceil(totalQuestions / questionsPerPage);
      let questions = [];
      let strokes = [];
      let currentStroke = null;
      const strokesPerQuestion = {}; // å­˜å‚¨æ¯ä¸ªé¢˜ç›®çš„ç¬”ç”»æ•°æ®
      const answersPerQuestion = {}; // å­˜å‚¨æ¯ä¸ªé¢˜ç›®çš„ç­”æ¡ˆå›¾ç‰‡æ•°æ® URL æˆ–æ•°å­—ç­”æ¡ˆ

      // è¾“å…¥æ¨¡å¼ï¼Œé»˜è®¤ä¸ºæ‰‹å†™æ¨¡å¼
      let inputMode = "handwriting"; // æˆ–è€… 'numeric'

      // è°ƒæ•´ç”»å¸ƒåˆ†è¾¨ç‡
      function setCanvasResolution() {
        const rect = canvas.getBoundingClientRect();
        const scale = window.devicePixelRatio || 1;

        canvas.width = rect.width * scale;
        canvas.height = rect.height * scale;
        ctx.scale(scale, scale);
      }

      // ç”Ÿæˆé¢˜ç›®
      function generateQuestions() {
        for (let i = 0; i < totalQuestions; i++) {
          const num1 = Math.floor(Math.random() * 10) + 1;
          const num2 = Math.floor(Math.random() * 10) + 1;
          questions.push(`${num1} + ${num2}`);
        }
      }

      // æ˜¾ç¤ºå½“å‰é¡µçš„é¢˜ç›®
      function displayQuestions() {
        questionsContainer.innerHTML = "";
        let startIndex = currentPage * questionsPerPage;
        let endIndex = Math.min(startIndex + questionsPerPage, totalQuestions);

        // è°ƒæ•´é¢˜ç›®é¡ºåºï¼Œä»ä¸Šåˆ°ä¸‹æ’åˆ—
        const columnCount = 2;
        const rowCount = Math.ceil((endIndex - startIndex) / columnCount);
        for (let row = 0; row < rowCount; row++) {
          for (let col = 0; col < columnCount; col++) {
            const index = startIndex + row + col * rowCount;
            if (index >= endIndex) continue;

            const questionDiv = document.createElement("div");
            questionDiv.className = "question";
            questionDiv.innerHTML = `
                        <div class="expression">
                            <div class="question-text">${index + 1}. ${
              questions[index]
            } =</div>
                            <div class="answer-container">
                                <img id="answer-img-${index}" class="answer-img" src="" alt="">
                                <div id="answer-text-${index}" class="answer-text"></div>
                            </div>
                        </div>
                    `;
            questionDiv.addEventListener("click", () =>
              setActiveQuestion(index)
            );
            questionsContainer.appendChild(questionDiv);

            // å¦‚æœå­˜åœ¨ç­”æ¡ˆï¼Œè®¾ç½®ç­”æ¡ˆçš„æ˜¾ç¤º
            if (answersPerQuestion[index]) {
              const answerData = answersPerQuestion[index];
              const answerImg = questionDiv.querySelector(
                `#answer-img-${index}`
              );
              const answerText = questionDiv.querySelector(
                `#answer-text-${index}`
              );
              if (answerData.type === "image") {
                answerImg.src = answerData.data;
                answerImg.style.display = "block";
                answerText.style.display = "none";
              } else if (answerData.type === "text") {
                answerText.textContent = answerData.data;
                answerImg.style.display = "none";
                answerText.style.display = "block";
              }
            }
          }
        }
        document.getElementById("page-number").textContent = currentPage + 1;
        document.getElementById("total-pages").textContent = totalPages; // æ›´æ–°æ€»é¡µæ•°æ˜¾ç¤º

        highlightActiveQuestion();

        // æ£€æŸ¥å½“å‰é¡µæ˜¯å¦è¿˜æœ‰æœªå®Œæˆçš„é¢˜ç›®
        const firstUnansweredIndex = getFirstUnansweredQuestionIndex();
        if (firstUnansweredIndex !== null) {
          setActiveQuestion(firstUnansweredIndex, false); // ä¸ä¿å­˜å½“å‰ç¬”è¿¹
        } else {
          // å¦‚æœæ‰€æœ‰é¢˜ç›®éƒ½å·²å®Œæˆï¼Œä¸é€‰ä¸­ä»»ä½•é¢˜ç›®
          activeQuestionIndex = null;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          strokes = [];
          highlightActiveQuestion();
          updateSelectedQuestionDisplay();
        }
      }

      // è·å–å½“å‰é¡µç¬¬ä¸€ä¸ªæœªå®Œæˆçš„é¢˜ç›®ç´¢å¼•
      function getFirstUnansweredQuestionIndex() {
        let startIndex = currentPage * questionsPerPage;
        let endIndex = Math.min(startIndex + questionsPerPage, totalQuestions);
        for (let index = startIndex; index < endIndex; index++) {
          if (!answersPerQuestion[index]) {
            return index;
          }
        }
        return null; // å½“å‰é¡µæ‰€æœ‰é¢˜ç›®éƒ½å·²å®Œæˆ
      }

      // è®¾ç½®æ¿€æ´»çš„é¢˜ç›®
      function setActiveQuestion(index, saveStrokes = true) {
        if (index >= 0 && index < totalQuestions) {
          if (saveStrokes && activeQuestionIndex !== null) {
            saveCurrentStrokes();
          }
          activeQuestionIndex = index;
          highlightActiveQuestion();
          // é‡ç½®ç”»å¸ƒæˆ–æ•°å­—è¾“å…¥
          if (inputMode === "handwriting") {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            strokes = [];
            if (strokesPerQuestion[activeQuestionIndex]) {
              strokes = strokesPerQuestion[activeQuestionIndex].slice();
              redrawCanvas();
            }
          } else if (inputMode === "numeric") {
            numericInput = "";
            if (
              answersPerQuestion[activeQuestionIndex] &&
              answersPerQuestion[activeQuestionIndex].type === "text"
            ) {
              numericInput = answersPerQuestion[activeQuestionIndex].data;
            }
            updateNumericDisplay();
          }
          updateSelectedQuestionDisplay();
        }
      }

      // æ›´æ–°æ˜¾ç¤ºè¢«é€‰ä¸­çš„é¢˜ç›®
      function updateSelectedQuestionDisplay() {
        const selectedQuestionDiv =
          document.querySelector(".selected-question");
        if (activeQuestionIndex !== null) {
          selectedQuestionDiv.textContent =
            questions[activeQuestionIndex] + " =";
        } else {
          selectedQuestionDiv.textContent = "";
        }
      }

      // é«˜äº®å½“å‰æ¿€æ´»çš„é¢˜ç›®
      function highlightActiveQuestion() {
        document.querySelectorAll(".question").forEach((q) => {
          q.classList.remove("active");
        });
        if (activeQuestionIndex !== null) {
          const questionDivs = document.querySelectorAll(".question");
          for (let i = 0; i < questionDivs.length; i++) {
            const indexText =
              questionDivs[i].querySelector(".question-text").textContent;
            const index = parseInt(indexText.split(".")[0]) - 1;
            if (index === activeQuestionIndex) {
              questionDivs[i].classList.add("active");
              break;
            }
          }
        }
      }

      // å·¥å…·æŒ‰é’®äº‹ä»¶
      const penButton = document.getElementById("pen-button");
      const eraserButton = document.getElementById("eraser-button");
      penButton.classList.add("selected");

      penButton.addEventListener("click", () => {
        currentTool = "pen";
        penButton.classList.add("selected");
        eraserButton.classList.remove("selected");
      });
      eraserButton.addEventListener("click", () => {
        currentTool = "eraser";
        eraserButton.classList.add("selected");
        penButton.classList.remove("selected");
      });

      // åˆ‡æ¢è¾“å…¥æ¨¡å¼æŒ‰é’®äº‹ä»¶
      const toggleInputModeButton =
        document.getElementById("toggle-input-mode");
      toggleInputModeButton.addEventListener("click", toggleInputMode);

      function toggleInputMode() {
        if (inputMode === "handwriting") {
          inputMode = "numeric";
          // éšè—æ‰‹å†™ç›¸å…³å…ƒç´ 
          canvas.style.display = "none";
          document.getElementById("tool-buttons").style.display = "none";
          // æ˜¾ç¤ºæ•°å­—è¾“å…¥ç›¸å…³å…ƒç´ 
          document.getElementById("numeric-display").style.display = "flex";
          document.getElementById("numeric-keypad").style.display = "flex";
          // åˆå§‹åŒ–æ•°å­—è¾“å…¥
          numericInput = "";
          if (
            answersPerQuestion[activeQuestionIndex] &&
            answersPerQuestion[activeQuestionIndex].type === "text"
          ) {
            numericInput = answersPerQuestion[activeQuestionIndex].data;
          }
          updateNumericDisplay();
        } else {
          inputMode = "handwriting";
          // æ˜¾ç¤ºæ‰‹å†™ç›¸å…³å…ƒç´ 
          canvas.style.display = "block";
          document.getElementById("tool-buttons").style.display = "flex";
          // éšè—æ•°å­—è¾“å…¥ç›¸å…³å…ƒç´ 
          document.getElementById("numeric-display").style.display = "none";
          document.getElementById("numeric-keypad").style.display = "none";
        }
      }

      // æ•°å­—è¾“å…¥ç›¸å…³
      let numericInput = "";
      const numericDisplay = document.getElementById("numeric-display");
      const numericKeypad = document.getElementById("numeric-keypad");

      // ç”Ÿæˆæ•°å­—æŒ‰é’®
      function generateNumericKeypad() {
        numericKeypad.innerHTML = "";
        for (let i = 1; i <= 9; i++) {
          const button = document.createElement("button");
          button.textContent = i;
          button.addEventListener("click", () => addNumericInput(i));
          numericKeypad.appendChild(button);
        }
        // æ·»åŠ  0 æŒ‰é’®
        const zeroButton = document.createElement("button");
        zeroButton.textContent = 0;
        zeroButton.addEventListener("click", () => addNumericInput(0));
        numericKeypad.appendChild(zeroButton);
        // æ·»åŠ åˆ é™¤æŒ‰é’®
        const deleteButton = document.createElement("button");
        deleteButton.textContent = "âŒ«";
        deleteButton.addEventListener("click", deleteNumericInput);
        numericKeypad.appendChild(deleteButton);
      }

      function addNumericInput(value) {
        numericInput += value.toString();
        updateNumericDisplay();
      }

      function deleteNumericInput() {
        numericInput = numericInput.slice(0, -1);
        updateNumericDisplay();
      }

      function updateNumericDisplay() {
        numericDisplay.textContent = numericInput;
      }

      // ä¼˜åŒ–ç»˜åˆ¶æ€§èƒ½
      let lastPos = { x: 0, y: 0 };
      function getCanvasPosition(event) {
        const rect = canvas.getBoundingClientRect();
        let x, y;
        if (event.touches && event.touches[0]) {
          x = event.touches[0].clientX - rect.left;
          y = event.touches[0].clientY - rect.top;
        } else {
          x = event.clientX - rect.left;
          y = event.clientY - rect.top;
        }
        return { x, y };
      }

      function startDrawing(event) {
        if (activeQuestionIndex === null) {
          alert("è¯·é€‰æ‹©ä¸€ä¸ªé¢˜ç›®è¿›è¡Œä½œç­”ï¼");
          return;
        }
        if (inputMode !== "handwriting") return;
        drawing = true;
        const pos = getCanvasPosition(event);
        lastPos = pos;
        currentStroke = {
          tool: currentTool,
          points: [pos],
        };
      }

      function stopDrawing() {
        if (drawing && currentStroke) {
          strokes.push(currentStroke);
        }
        drawing = false;
        currentStroke = null;
      }

      function draw(event) {
        if (!drawing) return;
        event.preventDefault(); // é˜²æ­¢æ»šåŠ¨
        const pos = getCanvasPosition(event);

        if (currentTool === "eraser") {
          eraseStrokeAt(pos);
        } else {
          ctx.lineCap = "round";
          ctx.globalCompositeOperation = "source-over";
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 8;

          ctx.beginPath();
          ctx.moveTo(lastPos.x, lastPos.y);
          ctx.lineTo(pos.x, pos.y);
          ctx.stroke();

          lastPos = pos;
          currentStroke.points.push(pos);
        }
      }

      function eraseStrokeAt(pos) {
        const eraserRadius = 10;
        let strokeErased = false;

        for (let i = strokes.length - 1; i >= 0; i--) {
          const stroke = strokes[i];
          for (let j = 0; j < stroke.points.length; j++) {
            const point = stroke.points[j];
            const dx = point.x - pos.x;
            const dy = point.y - pos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance <= eraserRadius) {
              strokes.splice(i, 1);
              strokeErased = true;
              break;
            }
          }
          if (strokeErased) break;
        }

        if (strokeErased) {
          redrawCanvas();
        }
      }

      function redrawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.lineCap = "round";
        ctx.globalCompositeOperation = "source-over";

        for (const stroke of strokes) {
          if (stroke.tool === "pen") {
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 8;
          } else {
            continue;
          }

          ctx.beginPath();
          const points = stroke.points;
          if (points.length > 0) {
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
              ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
          }
        }
      }

      function saveCurrentStrokes() {
        if (activeQuestionIndex !== null) {
          strokesPerQuestion[activeQuestionIndex] = strokes.slice();
        }
      }

      // ç¡®è®¤ç­”æ¡ˆ
      function confirmAnswer() {
        if (activeQuestionIndex === null) {
          alert("è¯·é€‰æ‹©ä¸€ä¸ªé¢˜ç›®è¿›è¡Œä½œç­”ï¼");
          return;
        }

        if (inputMode === "handwriting") {
          saveCurrentStrokes();

          // è®¡ç®—ç¬”è¿¹çš„è¾¹ç•Œæ¡†
          const boundingBox = getStrokesBoundingBox(strokes);
          if (boundingBox) {
            const { minX, minY, maxX, maxY } = boundingBox;
            const padding = 10; // æ·»åŠ 10åƒç´ çš„é—´è·
            const width = maxX - minX + padding * 2;
            const height = maxY - minY + padding * 2;

            // åˆ›å»ºä¸€ä¸ªæ–°çš„ç”»å¸ƒï¼Œå¤§å°ä¸ºç¬”è¿¹çš„åŒºåŸŸ
            const tempCanvas = document.createElement("canvas");
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext("2d");

            // å°†ç¬”è¿¹é‡ç»˜åˆ°æ–°çš„ç”»å¸ƒä¸Š
            tempCtx.lineCap = "round";
            tempCtx.globalCompositeOperation = "source-over";
            tempCtx.strokeStyle = "#000";
            tempCtx.lineWidth = 8;

            for (const stroke of strokes) {
              if (stroke.tool === "pen") {
                tempCtx.beginPath();
                const points = stroke.points;
                if (points.length > 0) {
                  tempCtx.moveTo(
                    points[0].x - minX + padding,
                    points[0].y - minY + padding
                  );
                  for (let i = 1; i < points.length; i++) {
                    tempCtx.lineTo(
                      points[i].x - minX + padding,
                      points[i].y - minY + padding
                    );
                  }
                  tempCtx.stroke();
                }
              }
            }

            // å°†è£å‰ªåçš„ç”»å¸ƒè½¬æ¢ä¸ºå›¾åƒï¼Œä¿å­˜ç­”æ¡ˆ
            const imgData = tempCanvas.toDataURL();
            answersPerQuestion[activeQuestionIndex] = {
              type: "image",
              data: imgData,
            };
          } else {
            // å¦‚æœæ²¡æœ‰ç¬”è¿¹ï¼Œæ¸…ç©ºç­”æ¡ˆ
            delete answersPerQuestion[activeQuestionIndex];
          }
        } else if (inputMode === "numeric") {
          if (numericInput !== "") {
            answersPerQuestion[activeQuestionIndex] = {
              type: "text",
              data: numericInput,
            };
          } else {
            // å¦‚æœæ²¡æœ‰è¾“å…¥ï¼Œæ¸…ç©ºç­”æ¡ˆ
            delete answersPerQuestion[activeQuestionIndex];
          }
        }

        // æ›´æ–°ç­”æ¡ˆæ˜¾ç¤º
        const answerContainer = document.querySelector(
          `#answer-img-${activeQuestionIndex}`
        ).parentNode;
        const answerImg = answerContainer.querySelector(
          `#answer-img-${activeQuestionIndex}`
        );
        const answerText = answerContainer.querySelector(
          `#answer-text-${activeQuestionIndex}`
        );
        const answerData = answersPerQuestion[activeQuestionIndex];

        if (answerData) {
          if (answerData.type === "image") {
            answerImg.src = answerData.data;
            answerImg.style.display = "block";
            answerText.style.display = "none";
          } else if (answerData.type === "text") {
            answerText.textContent = answerData.data;
            answerImg.style.display = "none";
            answerText.style.display = "block";
          }
        } else {
          answerImg.src = "";
          answerText.textContent = "";
        }

        // æ£€æŸ¥æ˜¯å¦æ˜¯å½“å‰é¡µçš„æœ€åä¸€é¢˜
        const startIndex = currentPage * questionsPerPage;
        const endIndex = Math.min(
          startIndex + questionsPerPage,
          totalQuestions
        );
        if (activeQuestionIndex < endIndex - 1) {
          // è¿˜æœ‰ä¸‹ä¸€é¢˜ï¼Œæ¿€æ´»ä¸‹ä¸€é¢˜
          setActiveQuestion(activeQuestionIndex + 1);
        } else {
          // å½“å‰é¡µå·²å®Œæˆæœ€åä¸€é¢˜ï¼Œä¸è‡ªåŠ¨è·³è½¬åˆ°ä¸‹ä¸€é¡µï¼Œä¸æ˜¾ç¤ºå¼¹çª—
          // ä¸é€‰ä¸­ä»»ä½•é¢˜ç›®
          activeQuestionIndex = null;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          strokes = [];
          numericInput = "";
          highlightActiveQuestion();
          updateSelectedQuestionDisplay();
        }
      }

      // è®¡ç®—ç¬”è¿¹çš„è¾¹ç•Œæ¡†
      function getStrokesBoundingBox(strokes) {
        if (strokes.length === 0) return null;
        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;
        for (const stroke of strokes) {
          for (const point of stroke.points) {
            if (point.x < minX) minX = point.x;
            if (point.y < minY) minY = point.y;
            if (point.x > maxX) maxX = point.x;
            if (point.y > maxY) maxY = point.y;
          }
        }
        return { minX, minY, maxX, maxY };
      }

      // ç»‘å®šç¿»é¡µæŒ‰é’®äº‹ä»¶
      document.getElementById("prev-page").addEventListener("click", () => {
        if (currentPage > 0) {
          if (inputMode === "handwriting") saveCurrentStrokes();
          currentPage--;
          displayQuestions();
        }
      });

      document.getElementById("next-page").addEventListener("click", () => {
        if (currentPage < totalPages - 1) {
          if (inputMode === "handwriting") saveCurrentStrokes();
          currentPage++;
          displayQuestions();
        }
      });

      // ç»‘å®šäº‹ä»¶
      canvas.addEventListener("mousedown", startDrawing);
      canvas.addEventListener("mouseup", stopDrawing);
      canvas.addEventListener("mouseout", stopDrawing);
      canvas.addEventListener("mousemove", draw);

      canvas.addEventListener("touchstart", startDrawing);
      canvas.addEventListener("touchend", stopDrawing);
      canvas.addEventListener("touchcancel", stopDrawing);
      canvas.addEventListener("touchmove", draw);

      // åˆå§‹åŒ–
      setCanvasResolution();
      generateQuestions();
      displayQuestions();
      generateNumericKeypad();

      // ç¡®ä¿é»˜è®¤æ˜¾ç¤ºæ‰‹å†™ç›¸å…³å…ƒç´ ï¼Œéšè—æ•°å­—è¾“å…¥ç›¸å…³å…ƒç´ 
      canvas.style.display = "block";
      document.getElementById("tool-buttons").style.display = "flex";
      document.getElementById("numeric-display").style.display = "none";
      document.getElementById("numeric-keypad").style.display = "none";

      // è°ƒæ•´ç”»å¸ƒåˆ†è¾¨ç‡
      window.addEventListener("resize", setCanvasResolution);
    </script>
  </body>
</html>
